# 微服务统一鉴权中心实现文档

## 一、项目概述

### 1.1 项目背景
本项目采用Spring Cloud微服务架构，需要建立一个统一的鉴权中心来管理所有微服务的认证和授权。鉴权中心基于Spring Security和JWT技术实现，提供token的生成、验证和权限管理功能。

### 1.2 技术栈
- **框架**: Spring Boot 3.2.4 + Spring Cloud 2023.0.1
- **安全框架**: Spring Security 6.5.2
- **认证方式**: JWT (JSON Web Token)
- **注册中心**: Nacos
- **网关**: Spring Cloud Gateway
- **缓存**: Redis
- **数据库**: MySQL 9.3.0

## 二、系统架构设计

### 2.1 整体架构
```
                     ┌──────────────┐
                     │   前端应用    │
                     └──────┬───────┘
                            │
                     ┌──────▼───────┐
                     │  API Gateway  │
                     │   (8080)      │
                     └──────┬────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
   ┌────▼────┐      ┌──────▼────────┐   ┌─────▼─────┐
   │Auth      │      │ User Service   │   │ Other      │
   │Service   │      │                │   │ Services   │
   └──────────┘      └────────────────┘   └────────────┘
        │                   │                   │
        └───────────────────┼───────────────────┘
                            │
                     ┌──────▼───────┐
                     │     Redis     │
                     └───────────────┘
```

### 2.2 认证流程
1. 用户通过网关发送登录请求到鉴权服务
2. 鉴权服务验证用户身份，生成JWT Token
3. 客户端携带Token访问其他微服务
4. 各微服务通过Security配置验证Token有效性
5. Token包含用户信息和权限，无需再次查询

## 三、核心模块设计

### 3.1 鉴权中心模块 (chat-book-cloud-auth)

#### 3.1.1 模块结构
```
chat-book-cloud-auth/
├── src/main/java/fun/amireux/chat/book/auth/
│   ├── controller/          # 控制层
│   │   └── AuthController.java
│   ├── service/             # 服务层
│   │   ├── AuthService.java
│   │   └── impl/
│   │       └── AuthServiceImpl.java
│   ├── entity/              # 实体类
│   │   ├── User.java
│   │   └── Role.java
│   ├── dto/                 # 数据传输对象
│   │   ├── LoginDTO.java
│   │   ├── RegisterDTO.java
│   │   └── TokenResponse.java
│   ├── config/              # 配置类
│   │   └── AuthServerConfig.java
│   └── AuthApplication.java # 启动类
└── src/main/resources/
    ├── application.yml
    └── bootstrap.yml
```

#### 3.1.2 核心功能实现

##### 登录认证接口
```java
@RestController
@RequestMapping("/auth")
public class AuthController {

    @Autowired
    private AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<TokenResponse> login(@RequestBody LoginDTO loginDTO) {
        // 验证用户名密码
        User user = authService.authenticate(loginDTO);

        // 生成JWT Token
        String token = JwtUtil.generateToken(
            new LoginRequest(user.getUsername(), user.getPassword(), user.getRole())
        );

        // 将Token存入Redis，设置过期时间
        redisTemplate.opsForValue().set(
            "token:" + user.getUsername(),
            token,
            1,
            TimeUnit.HOURS
        );

        return ResponseEntity.ok(new TokenResponse(token, user.getRole()));
    }

    @PostMapping("/logout")
    public ResponseEntity<Void> logout(@RequestHeader("Authorization") String token) {
        // 解析Token获取用户信息
        Claims claims = JwtUtil.parseToken(token.replace("Bearer ", ""));

        // 从Redis中删除Token
        redisTemplate.delete("token:" + claims.getSubject());

        return ResponseEntity.ok().build();
    }

    @PostMapping("/refresh")
    public ResponseEntity<TokenResponse> refresh(@RequestHeader("Authorization") String oldToken) {
        // 验证旧Token并生成新Token
        String newToken = authService.refreshToken(oldToken);
        return ResponseEntity.ok(new TokenResponse(newToken));
    }
}
```

##### 用户注册接口
```java
@PostMapping("/register")
public ResponseEntity<User> register(@RequestBody RegisterDTO registerDTO) {
    // 检查用户名是否已存在
    if (authService.existsByUsername(registerDTO.getUsername())) {
        throw new BusinessException("用户名已存在");
    }

    // 密码加密
    String encryptedPassword = passwordEncoder.encode(registerDTO.getPassword());

    // 创建用户
    User user = new User();
    user.setUsername(registerDTO.getUsername());
    user.setPassword(encryptedPassword);
    user.setRole("ROLE_USER"); // 默认角色

    User savedUser = authService.saveUser(user);
    return ResponseEntity.ok(savedUser);
}
```

##### Token验证接口
```java
@GetMapping("/verify")
public ResponseEntity<Map<String, Object>> verify(@RequestHeader("Authorization") String token) {
    try {
        Claims claims = JwtUtil.parseToken(token.replace("Bearer ", ""));

        Map<String, Object> result = new HashMap<>();
        result.put("valid", true);
        result.put("username", claims.getSubject());
        result.put("role", claims.get("role"));
        result.put("expiration", claims.getExpiration());

        return ResponseEntity.ok(result);
    } catch (Exception e) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
            .body(Map.of("valid", false, "message", e.getMessage()));
    }
}
```

### 3.2 JWT工具类实现

基于现有的JwtUtil类，建议增强如下功能：

```java
public class JwtUtil {
    private static final String SECRET = "PXrQbuCwXwOZzkML/Vm2S5rSwt1iybvmKtGDzVEu+Hc=";
    private static final long EXPIRATION = 1000 * 60 * 60; // 1小时
    private static final long REFRESH_EXPIRATION = 1000 * 60 * 60 * 24 * 7; // 7天

    private static final SecretKey SECRET_KEY = Keys.hmacShaKeyFor(SECRET.getBytes());

    // 生成访问Token
    public static String generateAccessToken(LoginRequest loginRequest) {
        return generateToken(loginRequest, EXPIRATION);
    }

    // 生成刷新Token
    public static String generateRefreshToken(LoginRequest loginRequest) {
        return generateToken(loginRequest, REFRESH_EXPIRATION);
    }

    private static String generateToken(LoginRequest loginRequest, long expiration) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("role", loginRequest.getRole());
        claims.put("type", expiration == EXPIRATION ? "access" : "refresh");

        return Jwts.builder()
                .setSubject(loginRequest.getUsername())
                .addClaims(claims)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(SECRET_KEY, SignatureAlgorithm.HS256)
                .compact();
    }

    // 验证Token
    public static boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(SECRET_KEY)
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    // 从Token中获取用户名
    public static String getUsernameFromToken(String token) {
        return parseToken(token).getSubject();
    }

    // 从Token中获取角色
    public static String getRoleFromToken(String token) {
        return parseToken(token).get("role", String.class);
    }

    // 检查Token是否过期
    public static boolean isTokenExpired(String token) {
        return parseToken(token).getExpiration().before(new Date());
    }
}
```

### 3.3 Security配置

#### 3.3.1 鉴权服务Security配置
```java
@Configuration
@EnableWebSecurity
public class AuthServerConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http
            .csrf(AbstractHttpConfigurer::disable)
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/login", "/auth/register").permitAll()
                .requestMatchers("/auth/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
```

#### 3.3.2 微服务端Security配置
各微服务继承framework中的SecurityMvcConfig，已实现：
- JWT解码器配置
- 权限转换器配置
- 异常处理器配置
- 请求日志过滤器

### 3.4 网关集成

#### 3.4.1 网关路由配置
```yaml
spring:
  cloud:
    gateway:
      routes:
        # 鉴权服务路由
        - id: auth-service
          uri: lb://auth-server
          predicates:
            - Path=/api/auth/**
          filters:
            - StripPrefix=1

        # 需要认证的服务路由
        - id: user-service
          uri: lb://user-server
          predicates:
            - Path=/api/user/**
          filters:
            - StripPrefix=1
            - name: JwtAuthFilter  # 自定义JWT验证过滤器
```

#### 3.4.2 网关全局过滤器
```java
@Component
public class JwtAuthFilter implements GlobalFilter, Ordered {

    @Autowired
    private ReactiveJwtDecoder jwtDecoder;

    private final List<String> excludePaths = Arrays.asList(
        "/api/auth/login",
        "/api/auth/register"
    );

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getURI().getPath();

        // 白名单路径直接放行
        if (excludePaths.stream().anyMatch(path::startsWith)) {
            return chain.filter(exchange);
        }

        // 获取Token
        String token = exchange.getRequest().getHeaders()
            .getFirst(HttpHeaders.AUTHORIZATION);

        if (StringUtils.isEmpty(token) || !token.startsWith("Bearer ")) {
            return onError(exchange, "Token不存在或格式错误", HttpStatus.UNAUTHORIZED);
        }

        token = token.substring(7);

        // 验证Token
        return jwtDecoder.decode(token)
            .flatMap(jwt -> {
                // Token验证成功，将用户信息添加到请求头
                ServerHttpRequest request = exchange.getRequest().mutate()
                    .header("X-User-Name", jwt.getSubject())
                    .header("X-User-Role", jwt.getClaimAsString("role"))
                    .build();

                return chain.filter(exchange.mutate().request(request).build());
            })
            .onErrorResume(ex -> onError(exchange, "Token验证失败", HttpStatus.UNAUTHORIZED));
    }

    private Mono<Void> onError(ServerWebExchange exchange, String err, HttpStatus httpStatus) {
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(httpStatus);
        response.getHeaders().add("Content-Type", "application/json;charset=UTF-8");

        String result = "{\"code\":" + httpStatus.value() + ",\"message\":\"" + err + "\"}";
        DataBuffer buffer = response.bufferFactory().wrap(result.getBytes());
        return response.writeWith(Mono.just(buffer));
    }

    @Override
    public int getOrder() {
        return -100;
    }
}
```

## 四、数据库设计

### 4.1 用户表 (sys_user)
```sql
CREATE TABLE `sys_user` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `username` varchar(50) NOT NULL COMMENT '用户名',
  `password` varchar(100) NOT NULL COMMENT '密码',
  `email` varchar(100) DEFAULT NULL COMMENT '邮箱',
  `phone` varchar(20) DEFAULT NULL COMMENT '手机号',
  `status` tinyint DEFAULT '1' COMMENT '状态：0-禁用，1-正常',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_username` (`username`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

### 4.2 角色表 (sys_role)
```sql
CREATE TABLE `sys_role` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `role_name` varchar(50) NOT NULL COMMENT '角色名称',
  `role_code` varchar(50) NOT NULL COMMENT '角色编码',
  `description` varchar(200) DEFAULT NULL COMMENT '描述',
  `status` tinyint DEFAULT '1' COMMENT '状态：0-禁用，1-正常',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_role_code` (`role_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='角色表';
```

### 4.3 用户角色关联表 (sys_user_role)
```sql
CREATE TABLE `sys_user_role` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `user_id` bigint NOT NULL COMMENT '用户ID',
  `role_id` bigint NOT NULL COMMENT '角色ID',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_role_id` (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户角色关联表';
```

### 4.4 权限表 (sys_permission)
```sql
CREATE TABLE `sys_permission` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '权限ID',
  `parent_id` bigint DEFAULT '0' COMMENT '父权限ID',
  `permission_name` varchar(50) NOT NULL COMMENT '权限名称',
  `permission_code` varchar(100) NOT NULL COMMENT '权限编码',
  `permission_type` tinyint NOT NULL COMMENT '权限类型：1-菜单，2-按钮，3-接口',
  `path` varchar(200) DEFAULT NULL COMMENT '路径',
  `method` varchar(10) DEFAULT NULL COMMENT 'HTTP方法',
  `status` tinyint DEFAULT '1' COMMENT '状态：0-禁用，1-正常',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_parent_id` (`parent_id`),
  KEY `idx_permission_code` (`permission_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='权限表';
```

### 4.5 角色权限关联表 (sys_role_permission)
```sql
CREATE TABLE `sys_role_permission` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `role_id` bigint NOT NULL COMMENT '角色ID',
  `permission_id` bigint NOT NULL COMMENT '权限ID',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_role_id` (`role_id`),
  KEY `idx_permission_id` (`permission_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='角色权限关联表';
```

## 五、接口设计

### 5.1 认证相关接口

| 接口名称 | 请求方式 | 接口路径 | 权限要求 | 说明 |
|---------|---------|---------|---------|------|
| 用户登录 | POST | /auth/login | 无 | 验证用户名密码，返回Token |
| 用户注册 | POST | /auth/register | 无 | 注册新用户 |
| 退出登录 | POST | /auth/logout | 需认证 | 清除Token |
| 刷新Token | POST | /auth/refresh | 需认证 | 使用refreshToken换取新的accessToken |
| 验证Token | GET | /auth/verify | 需认证 | 验证Token有效性 |
| 获取用户信息 | GET | /auth/userinfo | 需认证 | 获取当前登录用户信息 |

### 5.2 用户管理接口

| 接口名称 | 请求方式 | 接口路径 | 权限要求 | 说明 |
|---------|---------|---------|---------|------|
| 用户列表 | GET | /auth/users | ADMIN | 分页查询用户列表 |
| 用户详情 | GET | /auth/users/{id} | ADMIN | 获取用户详情 |
| 创建用户 | POST | /auth/users | ADMIN | 创建新用户 |
| 更新用户 | PUT | /auth/users/{id} | ADMIN | 更新用户信息 |
| 删除用户 | DELETE | /auth/users/{id} | ADMIN | 删除用户 |
| 重置密码 | POST | /auth/users/{id}/reset-password | ADMIN | 重置用户密码 |

### 5.3 角色管理接口

| 接口名称 | 请求方式 | 接口路径 | 权限要求 | 说明 |
|---------|---------|---------|---------|------|
| 角色列表 | GET | /auth/roles | ADMIN | 查询所有角色 |
| 创建角色 | POST | /auth/roles | ADMIN | 创建新角色 |
| 更新角色 | PUT | /auth/roles/{id} | ADMIN | 更新角色信息 |
| 删除角色 | DELETE | /auth/roles/{id} | ADMIN | 删除角色 |
| 分配权限 | POST | /auth/roles/{id}/permissions | ADMIN | 为角色分配权限 |

### 5.4 权限管理接口

| 接口名称 | 请求方式 | 接口路径 | 权限要求 | 说明 |
|---------|---------|---------|---------|------|
| 权限列表 | GET | /auth/permissions | ADMIN | 查询所有权限 |
| 权限树 | GET | /auth/permissions/tree | ADMIN | 获取权限树结构 |
| 创建权限 | POST | /auth/permissions | ADMIN | 创建新权限 |
| 更新权限 | PUT | /auth/permissions/{id} | ADMIN | 更新权限信息 |
| 删除权限 | DELETE | /auth/permissions/{id} | ADMIN | 删除权限 |

## 六、配置文件

### 6.1 鉴权服务配置 (application.yml)
```yaml
server:
  port: 9001

spring:
  application:
    name: auth-server

  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/auth_db?useUnicode=true&characterEncoding=utf-8
    username: root
    password: password

  redis:
    host: localhost
    port: 6379
    password:
    database: 0
    lettuce:
      pool:
        max-active: 8
        max-wait: -1
        max-idle: 8
        min-idle: 0

  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: dev
      config:
        server-addr: localhost:8848
        namespace: dev
        file-extension: yaml

# JWT配置
jwt:
  secret: PXrQbuCwXwOZzkML/Vm2S5rSwt1iybvmKtGDzVEu+Hc=
  expiration: 3600000  # 1小时
  refresh-expiration: 604800000  # 7天
  header: Authorization
  prefix: Bearer

# MyBatis配置
mybatis-plus:
  mapper-locations: classpath:mapper/**/*.xml
  type-aliases-package: fun.amireux.chat.book.auth.entity
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

# 日志配置
logging:
  level:
    fun.amireux.chat.book.auth: DEBUG
    org.springframework.security: DEBUG
```

### 6.2 微服务端配置示例
```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          # 如果使用对称密钥
          secret: PXrQbuCwXwOZzkML/Vm2S5rSwt1iybvmKtGDzVEu+Hc=
          # 如果使用公钥验证（推荐生产环境）
          # public-key-location: classpath:public.key

# 安全白名单配置
security:
  ignore:
    urls:
      - /actuator/**
      - /doc.html
      - /swagger-ui/**
      - /v3/api-docs/**
```

## 七、实施步骤

### 7.1 第一阶段：基础框架搭建
1. 创建auth-service模块
2. 集成Spring Security和JWT
3. 实现基本的登录、注册功能
4. 配置Redis缓存

### 7.2 第二阶段：功能完善
1. 实现用户、角色、权限管理
2. 添加Token刷新机制
3. 实现权限验证注解
4. 添加操作日志记录

### 7.3 第三阶段：网关集成
1. 配置网关路由
2. 实现全局Token验证过滤器
3. 处理跨域问题
4. 添加限流配置

### 7.4 第四阶段：服务集成
1. 各微服务集成Security配置
2. 统一异常处理
3. 添加服务间调用认证
4. 性能优化

## 八、安全建议

### 8.1 Token安全
- 使用HTTPS传输Token
- Token定期轮换
- 实现Token黑名单机制
- 合理设置Token过期时间

### 8.2 密码安全
- 使用BCrypt或其他强加密算法
- 实施密码复杂度要求
- 添加登录失败次数限制
- 实现验证码机制

### 8.3 接口安全
- 实施接口访问频率限制
- 添加IP白名单/黑名单
- 记录审计日志
- 实施数据脱敏

### 8.4 数据安全
- 敏感数据加密存储
- 实施数据备份策略
- 添加数据访问权限控制
- 定期安全审计

## 九、监控与运维

### 9.1 监控指标
- Token生成/验证QPS
- 登录成功/失败率
- 接口响应时间
- Redis命中率

### 9.2 日志管理
- 登录日志
- 操作日志
- 异常日志
- 审计日志

### 9.3 告警配置
- Token验证失败率过高
- 登录失败次数过多
- 服务响应时间过长
- Redis连接异常

## 十、总结

本鉴权中心设计采用了业界成熟的JWT + Spring Security方案，具有以下特点：

1. **无状态认证**：使用JWT实现无状态认证，提高系统可扩展性
2. **统一管理**：集中管理所有微服务的认证授权
3. **灵活配置**：支持多种认证方式和权限模型
4. **高性能**：使用Redis缓存，减少数据库访问
5. **安全可靠**：多重安全机制保障系统安全

后续可以根据业务需求，逐步增强功能，如：
- 集成OAuth2.0支持第三方登录
- 添加单点登录(SSO)功能
- 实现多租户支持
- 添加动态权限管理
- 集成审计日志系统